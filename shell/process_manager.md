# 进程管理

正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。

- 进程管理的作用
	- 判断服务器健康状态
	- 查看系统中所有进程
	- 杀死进程

## 进程管理

- 进程查看: ps 和 pstree 命令

> ps aux

查看系统中所有的进程，使用BSD操作系统格式

> ps -le

查看系统中所有进程，使用Linux标准格式

ps的选项：
 - -a 显示一个终端的所有进程，出了会话引线
 - -u 显示进程的归属用户及内存的使用情况
 - -x 显示没有控制终端的进程
 - -l 长格式显示。显示更加详细的信息
 - -e 显示所有进程， 和-a的作用一致

注意： ps aux 没有 `-`

进程信息：
- USER: 该进程是由哪个用户产生的
- PID:进程的ID
- %CPU:该进程占用CPU资源百分比
- %MEM:该进程占用物理内存百分比
- VSZ:该进程占用虚拟内存的大小，单位KB
- RSS:该进程占用实际物理内存的大小，单位KB
- TTY:该进程是在哪个终端中运行的，其中tty1-tty7代表本地控制台终端，tty1-tty6是本地字符界面终端，tty7是图形界面。pst/0-255代表虚拟终端
- STAT:进程的状态，常见的状态有：
 - -R 运行
 - -S 睡眠
 - -T 停止状态
 - -s 包含子进程
 - + 位于后台
START:该进程的启动时间
TIME:该进程占用CPU的运算时间，注意不是系统时间
COMMAND:产生此进程的命令名

> pstree [选项]

选项：
 - -p 显示进程的PID
 - -u 显示进程的所属用户

pstree用户显示进程树

- 进程查看: top 命令

top命令每隔3秒(默认)更新进程，查看系统进程详情，按CPU占比排序

选项：
 - -d 秒数
 - -b 使用批处理模式输出，一般和-n选项合用
 - -n 次数 指定top命令执行的次数

在top命令的交互模式中可以执行的命令:
 - ?或h 显示交互模式的帮助
 - P 以CPU使用率排序，默认
 - M 以内存的使用率排序
 - N 以PID排序
 - q 退出top

```
top - 22:08:55 up 2 days,  5:59,  4 users,  load average: 0.00, 0.01, 0.00
Tasks:  97 total,   1 running,  96 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni, 99.3%id,  0.0%wa,  0.0%hi,  0.0%si,  0.7%st
Mem:   1020212k total,   816576k used,   203636k free,   116628k buffers
Swap:        0k total,        0k used,        0k free,   366220k cached

PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 3384 root      20   0 15024 1300 1008 R  0.3  0.1   0:00.63 top
    1 root      20   0 19236 1432 1140 S  0.0  0.1   0:04.68 init
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd
```

## 工作管理
工作管理指的是在单个登录终端中同时管理多个工作的行为
注意：
 - 当前的登录终端，只能管理当前终端的工作
 - 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作
 - 放入后台执行的命令不能和前台用户有交互或者需要前台输入，否则放入后台只能暂停，而不能执行


放入后台的命令：
在命令后面加 &
```sh
find /  nginx.conf &
```

### 工作管理方法
- 把命令放入后台
```sh
tar -zcf etc.tar.gz /etc &
# 把命令放入后台，并在后台执行

top
# 按下ctrl + z 快捷键，放在后台暂停
```

- 查看后台的工作
> jobs [-l]
-l： 显示工作的PID

“+” 号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作。
“-” 代表倒数第二个放入后台的工作。

- 将后台暂停的工作恢复到前台执行
> fg %工作号

%可以省略， 工作号和PID不是一个东西

- 将后台暂停的工作恢复到后台执行
> bg %工作号

后台恢复执行的命令，是不能与前台有交互的，否则不能很恢复到回台执行

### 后台命令脱离终端执行
很多命令都是在终端中执行的，终端关掉或者logout退出登录后，在终端运行的程序会退出。有些服务比如mysql必须持续运行，需要在终端关闭后也运行， mysqld服务可以让MySQL在后头运行。

- 1.把需要后台执行的命令加入到/etc/rc.local文件
- 2.使用系统定时任务，让系统在指定时间执行某个后台命令
- 3.使用nohup命令: `nohup [命令] &`
举个例子, 使用nohop执行for.sh脚本文件；
/home/mhy/work/for.sh
```sh
#!bin/bash
for(( i=0; i<= 1000; i=i+1 ))
	do
		echo $i >> /home/mhy/work/for_lunp.log
		sleep 10s
	done
```
执行: `nohup /home/mhy/work/for.sh &`

### vmstat命令监控系统资源
> vmstat [刷新延时] [刷新次数]

```sh
vmstat 1 3
```
每隔1s输出一条记录，最后的输出结果为：
```
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 476040 119080 107908    0    0    49    12 1014  118  1  0 98  0  1
 0  0      0 476040 119080 107932    0    0     0     0  999   19  0  0 99  0  1
 0  0      0 476040 119080 107932    0    0     0     0 1002   15  0  0 99  0  1
```
1. procs: 进程信息字段
 - r: 等待运行的进程数，数量越大，系统越繁忙
 - b: 不可被唤醒的进程数，数量越大，系统越繁忙

2. memory: 内存信息字段, 单位都是KB
 - swpd: 虚拟内存的使用情况
 - free: 空闲的内存容量
 - buff: 缓冲的内存容量
 - cache: 缓存的内存容量

3. swap: 交换分区的信息字段，单位都是KB
 - si: 从磁盘中交换到内存中数据的数量
 - so: 从内存中交换到磁盘中数据的数量。

这两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差

4. io: 磁盘读写信息字段, 单位是块
 - bi: 从块设备读入数据的总量
 - bo: 写入块设备的数据的总量

这两个数越大，代表系统的I/O越繁忙

5. system: 系统信息字段
 - in: 每秒被中断的进程次数
 - cs

越大越耗费资源

6. cpu: cpu信息字段
 - us
 - sy
 - id: 空闲CPU的百分比
 - wa 
 - st

### dmesg 开机时内核检测信息
> dmesg

```sh
dmesg | grep CPU
```

### free 查看内存使用状态
> free

```sh
free [-b|-k|-m|-g]
```
free命令后面的几个选项用来选择显示的单位， -b: 字节， -k：KB...., 默认是-k,以KB显示。








**缓冲和缓存的区别**
简单来说缓存(cache)是用来加速数据从硬盘中读取的，而缓冲(buffer)是用来加速数据写入硬盘的


