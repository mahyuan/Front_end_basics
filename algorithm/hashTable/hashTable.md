## hashTable 散列

散列是一种很高效的数据结构，在数据量特别大的时候，性能很高，原因在于其时间复杂度为O(1)，像其他的一些数据结构，
在查找数据是可能需要遍历，时间复杂度一般为O(n)，所以，数据越大，散列的优势越明显。
list列表是有序的数据结构，删除中间位置的元素，后面的元素位置都要往前移动，数据越大，越慢。
栈和队列是一种特殊的列表，用于特殊场景，在某些场景下不适合使用。
链表是一种特殊的list，相比于list的优势在于不用在删除元素时移动后面元素的位置，只需改变指针即可，但是也有缺点，再查找元素是需要遍历。
散列相比于链表的优势，查找元素是已经知道元素的大概位置，如果没有碰撞的话，查找会更快。

散列原理是使用了list使用下标访问元素的特性，先声明一个list，分配好内存空间，在插入值时，根据定义好的hash函数计算一个hash值，
该值作为其在list中的位置，而计算hash的过程时间复杂度为O(1)，计算出hash值时，直接将其添加在list中的该位置即可（如果该位置没有被占用的话）

散列的使用过程中往往会出现碰撞的情况，所谓碰撞，就是指新添加的值的hash值对应的位置已经被占用的情况，针对这种情况，有开放寻址法和链表法来处理这种情况，

散列中使用**装载因子**来表示冲突的情况，装载因子越大，出现碰撞的概率越高，所以合理设置散列中list的大小需要根据所要存储的数据量合理设置，length过大会造成空间浪费，length过小，则会提高查找成本。

**装载因子 = 当前元素数量 / 数组长度**

下面简单说一下碰撞处理方法：

### 开放寻址法
所谓开放寻址法，即在散列发生碰撞时，寻址下一个位置，如果下一个位置为空，则将元素添加在当前空位置，如果不为空，则继续向下查找。
开放寻址法在添加元素时，需要将key和value都添加进去，这样才能在查找时根据key判断是不是正确的目标。

### 链表法
链表法，散列list中的每个位置存储时都是以链表的形式存储的，在碰撞时，在当前位置的链表的最后一个元素的指针指向当前值即可。
如果装载因子较大时，链表长度较长，散列查找就会变成链表查找，时间复杂度由o(1)向o(n)转变，所以还是涉及到刚才的问题，合理length设置。

刚才说到设置合理的length，这一点固然重要，但是在开发中经常会遇到无法预估数据量的情况，比如redis。这时候就需要扩大list的容量，但是在javascript中不需要考虑这个问题，因为javascript中的数组是可以自己扩容的

在其他静态语言中，数组list容量是固定的，在散列容量不够是需要rehash，此时的做法是：
1. 新生成一个list2，一般list2的length设置为之前的2倍， 原来的数组先称为list1
2. 此时后面要添加的元素直接添加进list2
3. 此时要删除的元素则需要遍历两个list，比如先遍历list2，没找到再遍历list1，直到找到它，然后删除它
4. 遍历list1，把list1中的元素添加进list2，list清空后，删除list1


[重学 HashTable](http://www.alloyteam.com/2020/12/15164/)
